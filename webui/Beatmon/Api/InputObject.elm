-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Beatmon.Api.InputObject exposing (AccountCondition, AccountConditionOptionalFields, AccountInput, AccountInputOptionalFields, AccountInputRequiredFields, AccountPatch, AccountPatchOptionalFields, AuthenticateInput, AuthenticateInputOptionalFields, AuthenticateInputRequiredFields, CreateAccountInput, CreateAccountInputOptionalFields, CreateAccountInputRequiredFields, CreateHeartbeatInput, CreateHeartbeatInputOptionalFields, CreateHeartbeatInputRequiredFields, CreateHeartbeatLogInput, CreateHeartbeatLogInputOptionalFields, CreateHeartbeatLogInputRequiredFields, DeleteAccountByAccountIdInput, DeleteAccountByAccountIdInputOptionalFields, DeleteAccountByAccountIdInputRequiredFields, DeleteAccountByEmailInput, DeleteAccountByEmailInputOptionalFields, DeleteAccountByEmailInputRequiredFields, DeleteAccountInput, DeleteAccountInputOptionalFields, DeleteAccountInputRequiredFields, DeleteHeartbeatByHeartbeatIdAndAccountIdInput, DeleteHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields, DeleteHeartbeatByHeartbeatIdAndAccountIdInputRequiredFields, DeleteHeartbeatByHeartbeatIdInput, DeleteHeartbeatByHeartbeatIdInputOptionalFields, DeleteHeartbeatByHeartbeatIdInputRequiredFields, DeleteHeartbeatInput, DeleteHeartbeatInputOptionalFields, DeleteHeartbeatInputRequiredFields, DeleteHeartbeatLogByDateAndHeartbeatIdInput, DeleteHeartbeatLogByDateAndHeartbeatIdInputOptionalFields, DeleteHeartbeatLogByDateAndHeartbeatIdInputRequiredFields, DeleteHeartbeatLogInput, DeleteHeartbeatLogInputOptionalFields, DeleteHeartbeatLogInputRequiredFields, HeartbeatCondition, HeartbeatConditionOptionalFields, HeartbeatInput, HeartbeatInputOptionalFields, HeartbeatLogCondition, HeartbeatLogConditionOptionalFields, HeartbeatLogInput, HeartbeatLogInputOptionalFields, HeartbeatLogInputRequiredFields, HeartbeatLogPatch, HeartbeatLogPatchOptionalFields, HeartbeatPatch, HeartbeatPatchOptionalFields, RefreshTokenInput, RefreshTokenInputOptionalFields, UpdateAccountByAccountIdInput, UpdateAccountByAccountIdInputOptionalFields, UpdateAccountByAccountIdInputRequiredFields, UpdateAccountByEmailInput, UpdateAccountByEmailInputOptionalFields, UpdateAccountByEmailInputRequiredFields, UpdateAccountInput, UpdateAccountInputOptionalFields, UpdateAccountInputRequiredFields, UpdateHeartbeatByHeartbeatIdAndAccountIdInput, UpdateHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields, UpdateHeartbeatByHeartbeatIdAndAccountIdInputRequiredFields, UpdateHeartbeatByHeartbeatIdInput, UpdateHeartbeatByHeartbeatIdInputOptionalFields, UpdateHeartbeatByHeartbeatIdInputRequiredFields, UpdateHeartbeatInput, UpdateHeartbeatInputOptionalFields, UpdateHeartbeatInputRequiredFields, UpdateHeartbeatLogByDateAndHeartbeatIdInput, UpdateHeartbeatLogByDateAndHeartbeatIdInputOptionalFields, UpdateHeartbeatLogByDateAndHeartbeatIdInputRequiredFields, UpdateHeartbeatLogInput, UpdateHeartbeatLogInputOptionalFields, UpdateHeartbeatLogInputRequiredFields, buildAccountCondition, buildAccountInput, buildAccountPatch, buildAuthenticateInput, buildCreateAccountInput, buildCreateHeartbeatInput, buildCreateHeartbeatLogInput, buildDeleteAccountByAccountIdInput, buildDeleteAccountByEmailInput, buildDeleteAccountInput, buildDeleteHeartbeatByHeartbeatIdAndAccountIdInput, buildDeleteHeartbeatByHeartbeatIdInput, buildDeleteHeartbeatInput, buildDeleteHeartbeatLogByDateAndHeartbeatIdInput, buildDeleteHeartbeatLogInput, buildHeartbeatCondition, buildHeartbeatInput, buildHeartbeatLogCondition, buildHeartbeatLogInput, buildHeartbeatLogPatch, buildHeartbeatPatch, buildRefreshTokenInput, buildUpdateAccountByAccountIdInput, buildUpdateAccountByEmailInput, buildUpdateAccountInput, buildUpdateHeartbeatByHeartbeatIdAndAccountIdInput, buildUpdateHeartbeatByHeartbeatIdInput, buildUpdateHeartbeatInput, buildUpdateHeartbeatLogByDateAndHeartbeatIdInput, buildUpdateHeartbeatLogInput, encodeAccountCondition, encodeAccountInput, encodeAccountPatch, encodeAuthenticateInput, encodeCreateAccountInput, encodeCreateHeartbeatInput, encodeCreateHeartbeatLogInput, encodeDeleteAccountByAccountIdInput, encodeDeleteAccountByEmailInput, encodeDeleteAccountInput, encodeDeleteHeartbeatByHeartbeatIdAndAccountIdInput, encodeDeleteHeartbeatByHeartbeatIdInput, encodeDeleteHeartbeatInput, encodeDeleteHeartbeatLogByDateAndHeartbeatIdInput, encodeDeleteHeartbeatLogInput, encodeHeartbeatCondition, encodeHeartbeatInput, encodeHeartbeatLogCondition, encodeHeartbeatLogInput, encodeHeartbeatLogPatch, encodeHeartbeatPatch, encodeRefreshTokenInput, encodeUpdateAccountByAccountIdInput, encodeUpdateAccountByEmailInput, encodeUpdateAccountInput, encodeUpdateHeartbeatByHeartbeatIdAndAccountIdInput, encodeUpdateHeartbeatByHeartbeatIdInput, encodeUpdateHeartbeatInput, encodeUpdateHeartbeatLogByDateAndHeartbeatIdInput, encodeUpdateHeartbeatLogInput)

import Beatmon.Api.Interface
import Beatmon.Api.Object
import Beatmon.Api.Scalar
import Beatmon.Api.Union
import Graphql.Field as Field exposing (Field)
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAccountCondition : (AccountConditionOptionalFields -> AccountConditionOptionalFields) -> AccountCondition
buildAccountCondition fillOptionals =
    let
        optionals =
            fillOptionals
                { accountId = Absent, email = Absent, isAdmin = Absent, isActive = Absent }
    in
    { accountId = optionals.accountId, email = optionals.email, isAdmin = optionals.isAdmin, isActive = optionals.isActive }


type alias AccountConditionOptionalFields =
    { accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, email : OptionalArgument String, isAdmin : OptionalArgument Bool, isActive : OptionalArgument Bool }


{-| Type for the AccountCondition input object.
-}
type alias AccountCondition =
    { accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, email : OptionalArgument String, isAdmin : OptionalArgument Bool, isActive : OptionalArgument Bool }


{-| Encode a AccountCondition into a value that can be used as an argument.
-}
encodeAccountCondition : AccountCondition -> Value
encodeAccountCondition input =
    Encode.maybeObject
        [ ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ), ( "email", Encode.string |> Encode.optional input.email ), ( "isAdmin", Encode.bool |> Encode.optional input.isAdmin ), ( "isActive", Encode.bool |> Encode.optional input.isActive ) ]


buildAccountInput : AccountInputRequiredFields -> (AccountInputOptionalFields -> AccountInputOptionalFields) -> AccountInput
buildAccountInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { accountId = Absent, isAdmin = Absent, isActive = Absent }
    in
    { accountId = optionals.accountId, email = required.email, isAdmin = optionals.isAdmin, isActive = optionals.isActive }


type alias AccountInputRequiredFields =
    { email : String }


type alias AccountInputOptionalFields =
    { accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, isAdmin : OptionalArgument Bool, isActive : OptionalArgument Bool }


{-| Type for the AccountInput input object.
-}
type alias AccountInput =
    { accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, email : String, isAdmin : OptionalArgument Bool, isActive : OptionalArgument Bool }


{-| Encode a AccountInput into a value that can be used as an argument.
-}
encodeAccountInput : AccountInput -> Value
encodeAccountInput input =
    Encode.maybeObject
        [ ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ), ( "email", Encode.string input.email |> Just ), ( "isAdmin", Encode.bool |> Encode.optional input.isAdmin ), ( "isActive", Encode.bool |> Encode.optional input.isActive ) ]


buildAccountPatch : (AccountPatchOptionalFields -> AccountPatchOptionalFields) -> AccountPatch
buildAccountPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { accountId = Absent, email = Absent, isAdmin = Absent, isActive = Absent }
    in
    { accountId = optionals.accountId, email = optionals.email, isAdmin = optionals.isAdmin, isActive = optionals.isActive }


type alias AccountPatchOptionalFields =
    { accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, email : OptionalArgument String, isAdmin : OptionalArgument Bool, isActive : OptionalArgument Bool }


{-| Type for the AccountPatch input object.
-}
type alias AccountPatch =
    { accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, email : OptionalArgument String, isAdmin : OptionalArgument Bool, isActive : OptionalArgument Bool }


{-| Encode a AccountPatch into a value that can be used as an argument.
-}
encodeAccountPatch : AccountPatch -> Value
encodeAccountPatch input =
    Encode.maybeObject
        [ ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ), ( "email", Encode.string |> Encode.optional input.email ), ( "isAdmin", Encode.bool |> Encode.optional input.isAdmin ), ( "isActive", Encode.bool |> Encode.optional input.isActive ) ]


buildAuthenticateInput : AuthenticateInputRequiredFields -> (AuthenticateInputOptionalFields -> AuthenticateInputOptionalFields) -> AuthenticateInput
buildAuthenticateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, email = required.email, password = required.password }


type alias AuthenticateInputRequiredFields =
    { email : String, password : String }


type alias AuthenticateInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the AuthenticateInput input object.
-}
type alias AuthenticateInput =
    { clientMutationId : OptionalArgument String, email : String, password : String }


{-| Encode a AuthenticateInput into a value that can be used as an argument.
-}
encodeAuthenticateInput : AuthenticateInput -> Value
encodeAuthenticateInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ) ]


buildCreateAccountInput : CreateAccountInputRequiredFields -> (CreateAccountInputOptionalFields -> CreateAccountInputOptionalFields) -> CreateAccountInput
buildCreateAccountInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, account = required.account }


type alias CreateAccountInputRequiredFields =
    { account : AccountInput }


type alias CreateAccountInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the CreateAccountInput input object.
-}
type alias CreateAccountInput =
    { clientMutationId : OptionalArgument String, account : AccountInput }


{-| Encode a CreateAccountInput into a value that can be used as an argument.
-}
encodeCreateAccountInput : CreateAccountInput -> Value
encodeCreateAccountInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "account", encodeAccountInput input.account |> Just ) ]


buildCreateHeartbeatInput : CreateHeartbeatInputRequiredFields -> (CreateHeartbeatInputOptionalFields -> CreateHeartbeatInputOptionalFields) -> CreateHeartbeatInput
buildCreateHeartbeatInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeat = required.heartbeat }


type alias CreateHeartbeatInputRequiredFields =
    { heartbeat : HeartbeatInput }


type alias CreateHeartbeatInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the CreateHeartbeatInput input object.
-}
type alias CreateHeartbeatInput =
    { clientMutationId : OptionalArgument String, heartbeat : HeartbeatInput }


{-| Encode a CreateHeartbeatInput into a value that can be used as an argument.
-}
encodeCreateHeartbeatInput : CreateHeartbeatInput -> Value
encodeCreateHeartbeatInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeat", encodeHeartbeatInput input.heartbeat |> Just ) ]


buildCreateHeartbeatLogInput : CreateHeartbeatLogInputRequiredFields -> (CreateHeartbeatLogInputOptionalFields -> CreateHeartbeatLogInputOptionalFields) -> CreateHeartbeatLogInput
buildCreateHeartbeatLogInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeatLog = required.heartbeatLog }


type alias CreateHeartbeatLogInputRequiredFields =
    { heartbeatLog : HeartbeatLogInput }


type alias CreateHeartbeatLogInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the CreateHeartbeatLogInput input object.
-}
type alias CreateHeartbeatLogInput =
    { clientMutationId : OptionalArgument String, heartbeatLog : HeartbeatLogInput }


{-| Encode a CreateHeartbeatLogInput into a value that can be used as an argument.
-}
encodeCreateHeartbeatLogInput : CreateHeartbeatLogInput -> Value
encodeCreateHeartbeatLogInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeatLog", encodeHeartbeatLogInput input.heartbeatLog |> Just ) ]


buildDeleteAccountByAccountIdInput : DeleteAccountByAccountIdInputRequiredFields -> (DeleteAccountByAccountIdInputOptionalFields -> DeleteAccountByAccountIdInputOptionalFields) -> DeleteAccountByAccountIdInput
buildDeleteAccountByAccountIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, accountId = required.accountId }


type alias DeleteAccountByAccountIdInputRequiredFields =
    { accountId : Beatmon.Api.Scalar.BigInt }


type alias DeleteAccountByAccountIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteAccountByAccountIdInput input object.
-}
type alias DeleteAccountByAccountIdInput =
    { clientMutationId : OptionalArgument String, accountId : Beatmon.Api.Scalar.BigInt }


{-| Encode a DeleteAccountByAccountIdInput into a value that can be used as an argument.
-}
encodeDeleteAccountByAccountIdInput : DeleteAccountByAccountIdInput -> Value
encodeDeleteAccountByAccountIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) input.accountId |> Just ) ]


buildDeleteAccountByEmailInput : DeleteAccountByEmailInputRequiredFields -> (DeleteAccountByEmailInputOptionalFields -> DeleteAccountByEmailInputOptionalFields) -> DeleteAccountByEmailInput
buildDeleteAccountByEmailInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, email = required.email }


type alias DeleteAccountByEmailInputRequiredFields =
    { email : String }


type alias DeleteAccountByEmailInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteAccountByEmailInput input object.
-}
type alias DeleteAccountByEmailInput =
    { clientMutationId : OptionalArgument String, email : String }


{-| Encode a DeleteAccountByEmailInput into a value that can be used as an argument.
-}
encodeDeleteAccountByEmailInput : DeleteAccountByEmailInput -> Value
encodeDeleteAccountByEmailInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "email", Encode.string input.email |> Just ) ]


buildDeleteAccountInput : DeleteAccountInputRequiredFields -> (DeleteAccountInputOptionalFields -> DeleteAccountInputOptionalFields) -> DeleteAccountInput
buildDeleteAccountInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId }


type alias DeleteAccountInputRequiredFields =
    { nodeId : Beatmon.Api.Scalar.Id }


type alias DeleteAccountInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteAccountInput input object.
-}
type alias DeleteAccountInput =
    { clientMutationId : OptionalArgument String, nodeId : Beatmon.Api.Scalar.Id }


{-| Encode a DeleteAccountInput into a value that can be used as an argument.
-}
encodeDeleteAccountInput : DeleteAccountInput -> Value
encodeDeleteAccountInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (\(Beatmon.Api.Scalar.Id raw) -> Encode.string raw) input.nodeId |> Just ) ]


buildDeleteHeartbeatByHeartbeatIdAndAccountIdInput : DeleteHeartbeatByHeartbeatIdAndAccountIdInputRequiredFields -> (DeleteHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields -> DeleteHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields) -> DeleteHeartbeatByHeartbeatIdAndAccountIdInput
buildDeleteHeartbeatByHeartbeatIdAndAccountIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeatId = required.heartbeatId, accountId = required.accountId }


type alias DeleteHeartbeatByHeartbeatIdAndAccountIdInputRequiredFields =
    { heartbeatId : Beatmon.Api.Scalar.Uuid, accountId : Beatmon.Api.Scalar.BigInt }


type alias DeleteHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteHeartbeatByHeartbeatIdAndAccountIdInput input object.
-}
type alias DeleteHeartbeatByHeartbeatIdAndAccountIdInput =
    { clientMutationId : OptionalArgument String, heartbeatId : Beatmon.Api.Scalar.Uuid, accountId : Beatmon.Api.Scalar.BigInt }


{-| Encode a DeleteHeartbeatByHeartbeatIdAndAccountIdInput into a value that can be used as an argument.
-}
encodeDeleteHeartbeatByHeartbeatIdAndAccountIdInput : DeleteHeartbeatByHeartbeatIdAndAccountIdInput -> Value
encodeDeleteHeartbeatByHeartbeatIdAndAccountIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) input.accountId |> Just ) ]


buildDeleteHeartbeatByHeartbeatIdInput : DeleteHeartbeatByHeartbeatIdInputRequiredFields -> (DeleteHeartbeatByHeartbeatIdInputOptionalFields -> DeleteHeartbeatByHeartbeatIdInputOptionalFields) -> DeleteHeartbeatByHeartbeatIdInput
buildDeleteHeartbeatByHeartbeatIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeatId = required.heartbeatId }


type alias DeleteHeartbeatByHeartbeatIdInputRequiredFields =
    { heartbeatId : Beatmon.Api.Scalar.Uuid }


type alias DeleteHeartbeatByHeartbeatIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteHeartbeatByHeartbeatIdInput input object.
-}
type alias DeleteHeartbeatByHeartbeatIdInput =
    { clientMutationId : OptionalArgument String, heartbeatId : Beatmon.Api.Scalar.Uuid }


{-| Encode a DeleteHeartbeatByHeartbeatIdInput into a value that can be used as an argument.
-}
encodeDeleteHeartbeatByHeartbeatIdInput : DeleteHeartbeatByHeartbeatIdInput -> Value
encodeDeleteHeartbeatByHeartbeatIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ) ]


buildDeleteHeartbeatInput : DeleteHeartbeatInputRequiredFields -> (DeleteHeartbeatInputOptionalFields -> DeleteHeartbeatInputOptionalFields) -> DeleteHeartbeatInput
buildDeleteHeartbeatInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId }


type alias DeleteHeartbeatInputRequiredFields =
    { nodeId : Beatmon.Api.Scalar.Id }


type alias DeleteHeartbeatInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteHeartbeatInput input object.
-}
type alias DeleteHeartbeatInput =
    { clientMutationId : OptionalArgument String, nodeId : Beatmon.Api.Scalar.Id }


{-| Encode a DeleteHeartbeatInput into a value that can be used as an argument.
-}
encodeDeleteHeartbeatInput : DeleteHeartbeatInput -> Value
encodeDeleteHeartbeatInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (\(Beatmon.Api.Scalar.Id raw) -> Encode.string raw) input.nodeId |> Just ) ]


buildDeleteHeartbeatLogByDateAndHeartbeatIdInput : DeleteHeartbeatLogByDateAndHeartbeatIdInputRequiredFields -> (DeleteHeartbeatLogByDateAndHeartbeatIdInputOptionalFields -> DeleteHeartbeatLogByDateAndHeartbeatIdInputOptionalFields) -> DeleteHeartbeatLogByDateAndHeartbeatIdInput
buildDeleteHeartbeatLogByDateAndHeartbeatIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, date = required.date, heartbeatId = required.heartbeatId }


type alias DeleteHeartbeatLogByDateAndHeartbeatIdInputRequiredFields =
    { date : Beatmon.Api.Scalar.Datetime, heartbeatId : Beatmon.Api.Scalar.Uuid }


type alias DeleteHeartbeatLogByDateAndHeartbeatIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteHeartbeatLogByDateAndHeartbeatIdInput input object.
-}
type alias DeleteHeartbeatLogByDateAndHeartbeatIdInput =
    { clientMutationId : OptionalArgument String, date : Beatmon.Api.Scalar.Datetime, heartbeatId : Beatmon.Api.Scalar.Uuid }


{-| Encode a DeleteHeartbeatLogByDateAndHeartbeatIdInput into a value that can be used as an argument.
-}
encodeDeleteHeartbeatLogByDateAndHeartbeatIdInput : DeleteHeartbeatLogByDateAndHeartbeatIdInput -> Value
encodeDeleteHeartbeatLogByDateAndHeartbeatIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "date", (\(Beatmon.Api.Scalar.Datetime raw) -> Encode.string raw) input.date |> Just ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ) ]


buildDeleteHeartbeatLogInput : DeleteHeartbeatLogInputRequiredFields -> (DeleteHeartbeatLogInputOptionalFields -> DeleteHeartbeatLogInputOptionalFields) -> DeleteHeartbeatLogInput
buildDeleteHeartbeatLogInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId }


type alias DeleteHeartbeatLogInputRequiredFields =
    { nodeId : Beatmon.Api.Scalar.Id }


type alias DeleteHeartbeatLogInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the DeleteHeartbeatLogInput input object.
-}
type alias DeleteHeartbeatLogInput =
    { clientMutationId : OptionalArgument String, nodeId : Beatmon.Api.Scalar.Id }


{-| Encode a DeleteHeartbeatLogInput into a value that can be used as an argument.
-}
encodeDeleteHeartbeatLogInput : DeleteHeartbeatLogInput -> Value
encodeDeleteHeartbeatLogInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (\(Beatmon.Api.Scalar.Id raw) -> Encode.string raw) input.nodeId |> Just ) ]


buildHeartbeatCondition : (HeartbeatConditionOptionalFields -> HeartbeatConditionOptionalFields) -> HeartbeatCondition
buildHeartbeatCondition fillOptionals =
    let
        optionals =
            fillOptionals
                { heartbeatId = Absent, accountId = Absent, name = Absent, notifyAfterSeconds = Absent }
    in
    { heartbeatId = optionals.heartbeatId, accountId = optionals.accountId, name = optionals.name, notifyAfterSeconds = optionals.notifyAfterSeconds }


type alias HeartbeatConditionOptionalFields =
    { heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, name : OptionalArgument String, notifyAfterSeconds : OptionalArgument Int }


{-| Type for the HeartbeatCondition input object.
-}
type alias HeartbeatCondition =
    { heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, name : OptionalArgument String, notifyAfterSeconds : OptionalArgument Int }


{-| Encode a HeartbeatCondition into a value that can be used as an argument.
-}
encodeHeartbeatCondition : HeartbeatCondition -> Value
encodeHeartbeatCondition input =
    Encode.maybeObject
        [ ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) |> Encode.optional input.heartbeatId ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ), ( "name", Encode.string |> Encode.optional input.name ), ( "notifyAfterSeconds", Encode.int |> Encode.optional input.notifyAfterSeconds ) ]


buildHeartbeatInput : (HeartbeatInputOptionalFields -> HeartbeatInputOptionalFields) -> HeartbeatInput
buildHeartbeatInput fillOptionals =
    let
        optionals =
            fillOptionals
                { heartbeatId = Absent, accountId = Absent, name = Absent, notifyAfterSeconds = Absent }
    in
    { heartbeatId = optionals.heartbeatId, accountId = optionals.accountId, name = optionals.name, notifyAfterSeconds = optionals.notifyAfterSeconds }


type alias HeartbeatInputOptionalFields =
    { heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, name : OptionalArgument String, notifyAfterSeconds : OptionalArgument Int }


{-| Type for the HeartbeatInput input object.
-}
type alias HeartbeatInput =
    { heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, name : OptionalArgument String, notifyAfterSeconds : OptionalArgument Int }


{-| Encode a HeartbeatInput into a value that can be used as an argument.
-}
encodeHeartbeatInput : HeartbeatInput -> Value
encodeHeartbeatInput input =
    Encode.maybeObject
        [ ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) |> Encode.optional input.heartbeatId ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ), ( "name", Encode.string |> Encode.optional input.name ), ( "notifyAfterSeconds", Encode.int |> Encode.optional input.notifyAfterSeconds ) ]


buildHeartbeatLogCondition : (HeartbeatLogConditionOptionalFields -> HeartbeatLogConditionOptionalFields) -> HeartbeatLogCondition
buildHeartbeatLogCondition fillOptionals =
    let
        optionals =
            fillOptionals
                { date = Absent, heartbeatId = Absent, accountId = Absent }
    in
    { date = optionals.date, heartbeatId = optionals.heartbeatId, accountId = optionals.accountId }


type alias HeartbeatLogConditionOptionalFields =
    { date : OptionalArgument Beatmon.Api.Scalar.Datetime, heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt }


{-| Type for the HeartbeatLogCondition input object.
-}
type alias HeartbeatLogCondition =
    { date : OptionalArgument Beatmon.Api.Scalar.Datetime, heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt }


{-| Encode a HeartbeatLogCondition into a value that can be used as an argument.
-}
encodeHeartbeatLogCondition : HeartbeatLogCondition -> Value
encodeHeartbeatLogCondition input =
    Encode.maybeObject
        [ ( "date", (\(Beatmon.Api.Scalar.Datetime raw) -> Encode.string raw) |> Encode.optional input.date ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) |> Encode.optional input.heartbeatId ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ) ]


buildHeartbeatLogInput : HeartbeatLogInputRequiredFields -> (HeartbeatLogInputOptionalFields -> HeartbeatLogInputOptionalFields) -> HeartbeatLogInput
buildHeartbeatLogInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { date = Absent, accountId = Absent }
    in
    { date = optionals.date, heartbeatId = required.heartbeatId, accountId = optionals.accountId }


type alias HeartbeatLogInputRequiredFields =
    { heartbeatId : Beatmon.Api.Scalar.Uuid }


type alias HeartbeatLogInputOptionalFields =
    { date : OptionalArgument Beatmon.Api.Scalar.Datetime, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt }


{-| Type for the HeartbeatLogInput input object.
-}
type alias HeartbeatLogInput =
    { date : OptionalArgument Beatmon.Api.Scalar.Datetime, heartbeatId : Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt }


{-| Encode a HeartbeatLogInput into a value that can be used as an argument.
-}
encodeHeartbeatLogInput : HeartbeatLogInput -> Value
encodeHeartbeatLogInput input =
    Encode.maybeObject
        [ ( "date", (\(Beatmon.Api.Scalar.Datetime raw) -> Encode.string raw) |> Encode.optional input.date ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ) ]


buildHeartbeatLogPatch : (HeartbeatLogPatchOptionalFields -> HeartbeatLogPatchOptionalFields) -> HeartbeatLogPatch
buildHeartbeatLogPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { date = Absent, heartbeatId = Absent, accountId = Absent }
    in
    { date = optionals.date, heartbeatId = optionals.heartbeatId, accountId = optionals.accountId }


type alias HeartbeatLogPatchOptionalFields =
    { date : OptionalArgument Beatmon.Api.Scalar.Datetime, heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt }


{-| Type for the HeartbeatLogPatch input object.
-}
type alias HeartbeatLogPatch =
    { date : OptionalArgument Beatmon.Api.Scalar.Datetime, heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt }


{-| Encode a HeartbeatLogPatch into a value that can be used as an argument.
-}
encodeHeartbeatLogPatch : HeartbeatLogPatch -> Value
encodeHeartbeatLogPatch input =
    Encode.maybeObject
        [ ( "date", (\(Beatmon.Api.Scalar.Datetime raw) -> Encode.string raw) |> Encode.optional input.date ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) |> Encode.optional input.heartbeatId ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ) ]


buildHeartbeatPatch : (HeartbeatPatchOptionalFields -> HeartbeatPatchOptionalFields) -> HeartbeatPatch
buildHeartbeatPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { heartbeatId = Absent, accountId = Absent, name = Absent, notifyAfterSeconds = Absent }
    in
    { heartbeatId = optionals.heartbeatId, accountId = optionals.accountId, name = optionals.name, notifyAfterSeconds = optionals.notifyAfterSeconds }


type alias HeartbeatPatchOptionalFields =
    { heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, name : OptionalArgument String, notifyAfterSeconds : OptionalArgument Int }


{-| Type for the HeartbeatPatch input object.
-}
type alias HeartbeatPatch =
    { heartbeatId : OptionalArgument Beatmon.Api.Scalar.Uuid, accountId : OptionalArgument Beatmon.Api.Scalar.BigInt, name : OptionalArgument String, notifyAfterSeconds : OptionalArgument Int }


{-| Encode a HeartbeatPatch into a value that can be used as an argument.
-}
encodeHeartbeatPatch : HeartbeatPatch -> Value
encodeHeartbeatPatch input =
    Encode.maybeObject
        [ ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) |> Encode.optional input.heartbeatId ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) |> Encode.optional input.accountId ), ( "name", Encode.string |> Encode.optional input.name ), ( "notifyAfterSeconds", Encode.int |> Encode.optional input.notifyAfterSeconds ) ]


buildRefreshTokenInput : (RefreshTokenInputOptionalFields -> RefreshTokenInputOptionalFields) -> RefreshTokenInput
buildRefreshTokenInput fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId }


type alias RefreshTokenInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the RefreshTokenInput input object.
-}
type alias RefreshTokenInput =
    { clientMutationId : OptionalArgument String }


{-| Encode a RefreshTokenInput into a value that can be used as an argument.
-}
encodeRefreshTokenInput : RefreshTokenInput -> Value
encodeRefreshTokenInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ) ]


buildUpdateAccountByAccountIdInput : UpdateAccountByAccountIdInputRequiredFields -> (UpdateAccountByAccountIdInputOptionalFields -> UpdateAccountByAccountIdInputOptionalFields) -> UpdateAccountByAccountIdInput
buildUpdateAccountByAccountIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, accountPatch = required.accountPatch, accountId = required.accountId }


type alias UpdateAccountByAccountIdInputRequiredFields =
    { accountPatch : AccountPatch, accountId : Beatmon.Api.Scalar.BigInt }


type alias UpdateAccountByAccountIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateAccountByAccountIdInput input object.
-}
type alias UpdateAccountByAccountIdInput =
    { clientMutationId : OptionalArgument String, accountPatch : AccountPatch, accountId : Beatmon.Api.Scalar.BigInt }


{-| Encode a UpdateAccountByAccountIdInput into a value that can be used as an argument.
-}
encodeUpdateAccountByAccountIdInput : UpdateAccountByAccountIdInput -> Value
encodeUpdateAccountByAccountIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "accountPatch", encodeAccountPatch input.accountPatch |> Just ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) input.accountId |> Just ) ]


buildUpdateAccountByEmailInput : UpdateAccountByEmailInputRequiredFields -> (UpdateAccountByEmailInputOptionalFields -> UpdateAccountByEmailInputOptionalFields) -> UpdateAccountByEmailInput
buildUpdateAccountByEmailInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, accountPatch = required.accountPatch, email = required.email }


type alias UpdateAccountByEmailInputRequiredFields =
    { accountPatch : AccountPatch, email : String }


type alias UpdateAccountByEmailInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateAccountByEmailInput input object.
-}
type alias UpdateAccountByEmailInput =
    { clientMutationId : OptionalArgument String, accountPatch : AccountPatch, email : String }


{-| Encode a UpdateAccountByEmailInput into a value that can be used as an argument.
-}
encodeUpdateAccountByEmailInput : UpdateAccountByEmailInput -> Value
encodeUpdateAccountByEmailInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "accountPatch", encodeAccountPatch input.accountPatch |> Just ), ( "email", Encode.string input.email |> Just ) ]


buildUpdateAccountInput : UpdateAccountInputRequiredFields -> (UpdateAccountInputOptionalFields -> UpdateAccountInputOptionalFields) -> UpdateAccountInput
buildUpdateAccountInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, accountPatch = required.accountPatch }


type alias UpdateAccountInputRequiredFields =
    { nodeId : Beatmon.Api.Scalar.Id, accountPatch : AccountPatch }


type alias UpdateAccountInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateAccountInput input object.
-}
type alias UpdateAccountInput =
    { clientMutationId : OptionalArgument String, nodeId : Beatmon.Api.Scalar.Id, accountPatch : AccountPatch }


{-| Encode a UpdateAccountInput into a value that can be used as an argument.
-}
encodeUpdateAccountInput : UpdateAccountInput -> Value
encodeUpdateAccountInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (\(Beatmon.Api.Scalar.Id raw) -> Encode.string raw) input.nodeId |> Just ), ( "accountPatch", encodeAccountPatch input.accountPatch |> Just ) ]


buildUpdateHeartbeatByHeartbeatIdAndAccountIdInput : UpdateHeartbeatByHeartbeatIdAndAccountIdInputRequiredFields -> (UpdateHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields -> UpdateHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields) -> UpdateHeartbeatByHeartbeatIdAndAccountIdInput
buildUpdateHeartbeatByHeartbeatIdAndAccountIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeatPatch = required.heartbeatPatch, heartbeatId = required.heartbeatId, accountId = required.accountId }


type alias UpdateHeartbeatByHeartbeatIdAndAccountIdInputRequiredFields =
    { heartbeatPatch : HeartbeatPatch, heartbeatId : Beatmon.Api.Scalar.Uuid, accountId : Beatmon.Api.Scalar.BigInt }


type alias UpdateHeartbeatByHeartbeatIdAndAccountIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateHeartbeatByHeartbeatIdAndAccountIdInput input object.
-}
type alias UpdateHeartbeatByHeartbeatIdAndAccountIdInput =
    { clientMutationId : OptionalArgument String, heartbeatPatch : HeartbeatPatch, heartbeatId : Beatmon.Api.Scalar.Uuid, accountId : Beatmon.Api.Scalar.BigInt }


{-| Encode a UpdateHeartbeatByHeartbeatIdAndAccountIdInput into a value that can be used as an argument.
-}
encodeUpdateHeartbeatByHeartbeatIdAndAccountIdInput : UpdateHeartbeatByHeartbeatIdAndAccountIdInput -> Value
encodeUpdateHeartbeatByHeartbeatIdAndAccountIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeatPatch", encodeHeartbeatPatch input.heartbeatPatch |> Just ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ), ( "accountId", (\(Beatmon.Api.Scalar.BigInt raw) -> Encode.string raw) input.accountId |> Just ) ]


buildUpdateHeartbeatByHeartbeatIdInput : UpdateHeartbeatByHeartbeatIdInputRequiredFields -> (UpdateHeartbeatByHeartbeatIdInputOptionalFields -> UpdateHeartbeatByHeartbeatIdInputOptionalFields) -> UpdateHeartbeatByHeartbeatIdInput
buildUpdateHeartbeatByHeartbeatIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeatPatch = required.heartbeatPatch, heartbeatId = required.heartbeatId }


type alias UpdateHeartbeatByHeartbeatIdInputRequiredFields =
    { heartbeatPatch : HeartbeatPatch, heartbeatId : Beatmon.Api.Scalar.Uuid }


type alias UpdateHeartbeatByHeartbeatIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateHeartbeatByHeartbeatIdInput input object.
-}
type alias UpdateHeartbeatByHeartbeatIdInput =
    { clientMutationId : OptionalArgument String, heartbeatPatch : HeartbeatPatch, heartbeatId : Beatmon.Api.Scalar.Uuid }


{-| Encode a UpdateHeartbeatByHeartbeatIdInput into a value that can be used as an argument.
-}
encodeUpdateHeartbeatByHeartbeatIdInput : UpdateHeartbeatByHeartbeatIdInput -> Value
encodeUpdateHeartbeatByHeartbeatIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeatPatch", encodeHeartbeatPatch input.heartbeatPatch |> Just ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ) ]


buildUpdateHeartbeatInput : UpdateHeartbeatInputRequiredFields -> (UpdateHeartbeatInputOptionalFields -> UpdateHeartbeatInputOptionalFields) -> UpdateHeartbeatInput
buildUpdateHeartbeatInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, heartbeatPatch = required.heartbeatPatch }


type alias UpdateHeartbeatInputRequiredFields =
    { nodeId : Beatmon.Api.Scalar.Id, heartbeatPatch : HeartbeatPatch }


type alias UpdateHeartbeatInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateHeartbeatInput input object.
-}
type alias UpdateHeartbeatInput =
    { clientMutationId : OptionalArgument String, nodeId : Beatmon.Api.Scalar.Id, heartbeatPatch : HeartbeatPatch }


{-| Encode a UpdateHeartbeatInput into a value that can be used as an argument.
-}
encodeUpdateHeartbeatInput : UpdateHeartbeatInput -> Value
encodeUpdateHeartbeatInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (\(Beatmon.Api.Scalar.Id raw) -> Encode.string raw) input.nodeId |> Just ), ( "heartbeatPatch", encodeHeartbeatPatch input.heartbeatPatch |> Just ) ]


buildUpdateHeartbeatLogByDateAndHeartbeatIdInput : UpdateHeartbeatLogByDateAndHeartbeatIdInputRequiredFields -> (UpdateHeartbeatLogByDateAndHeartbeatIdInputOptionalFields -> UpdateHeartbeatLogByDateAndHeartbeatIdInputOptionalFields) -> UpdateHeartbeatLogByDateAndHeartbeatIdInput
buildUpdateHeartbeatLogByDateAndHeartbeatIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, heartbeatLogPatch = required.heartbeatLogPatch, date = required.date, heartbeatId = required.heartbeatId }


type alias UpdateHeartbeatLogByDateAndHeartbeatIdInputRequiredFields =
    { heartbeatLogPatch : HeartbeatLogPatch, date : Beatmon.Api.Scalar.Datetime, heartbeatId : Beatmon.Api.Scalar.Uuid }


type alias UpdateHeartbeatLogByDateAndHeartbeatIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateHeartbeatLogByDateAndHeartbeatIdInput input object.
-}
type alias UpdateHeartbeatLogByDateAndHeartbeatIdInput =
    { clientMutationId : OptionalArgument String, heartbeatLogPatch : HeartbeatLogPatch, date : Beatmon.Api.Scalar.Datetime, heartbeatId : Beatmon.Api.Scalar.Uuid }


{-| Encode a UpdateHeartbeatLogByDateAndHeartbeatIdInput into a value that can be used as an argument.
-}
encodeUpdateHeartbeatLogByDateAndHeartbeatIdInput : UpdateHeartbeatLogByDateAndHeartbeatIdInput -> Value
encodeUpdateHeartbeatLogByDateAndHeartbeatIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "heartbeatLogPatch", encodeHeartbeatLogPatch input.heartbeatLogPatch |> Just ), ( "date", (\(Beatmon.Api.Scalar.Datetime raw) -> Encode.string raw) input.date |> Just ), ( "heartbeatId", (\(Beatmon.Api.Scalar.Uuid raw) -> Encode.string raw) input.heartbeatId |> Just ) ]


buildUpdateHeartbeatLogInput : UpdateHeartbeatLogInputRequiredFields -> (UpdateHeartbeatLogInputOptionalFields -> UpdateHeartbeatLogInputOptionalFields) -> UpdateHeartbeatLogInput
buildUpdateHeartbeatLogInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, heartbeatLogPatch = required.heartbeatLogPatch }


type alias UpdateHeartbeatLogInputRequiredFields =
    { nodeId : Beatmon.Api.Scalar.Id, heartbeatLogPatch : HeartbeatLogPatch }


type alias UpdateHeartbeatLogInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateHeartbeatLogInput input object.
-}
type alias UpdateHeartbeatLogInput =
    { clientMutationId : OptionalArgument String, nodeId : Beatmon.Api.Scalar.Id, heartbeatLogPatch : HeartbeatLogPatch }


{-| Encode a UpdateHeartbeatLogInput into a value that can be used as an argument.
-}
encodeUpdateHeartbeatLogInput : UpdateHeartbeatLogInput -> Value
encodeUpdateHeartbeatLogInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (\(Beatmon.Api.Scalar.Id raw) -> Encode.string raw) input.nodeId |> Just ), ( "heartbeatLogPatch", encodeHeartbeatLogPatch input.heartbeatLogPatch |> Just ) ]
